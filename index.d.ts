/**
 * The Algorithm object is a dictionary object WebIDL which is used to specify an algorithm 
 * and any additional parameters required to fully specify the desired operation.
 */
type AlgorithmIDentifier = string | Algorithm;

interface ArrayBufferView {
    /**
      * The ArrayBuffer instance referenced by the array.
      */
    buffer: ArrayBufferLike;

    /**
      * The length in bytes of the array.
      */
    byteLength: number;

    /**
      * The offset in bytes of the array.
      */
    byteOffset: number;
}

interface RandomSource {
    getRandomValues(array: ArrayBufferView): ArrayBufferView;
}

interface Crypto extends Object, RandomSource {
    readonly subtle: SubtleCrypto;
}

interface CryptoKey {
    readonly algorithm: KeyAlgorithm;
    readonly extractable: boolean;
    readonly type: string;
    readonly usages: string[];
}

declare var CryptoKey: {
    prototype: CryptoKey;
    new(): CryptoKey;
};

interface CryptoKeyPair {
    privateKey: CryptoKey;
    publicKey: CryptoKey;
}

declare var CryptoKeyPair: {
    prototype: CryptoKeyPair;
    new(): CryptoKeyPair;
};

/**
 * The `SubtleCrypto` interface represents a set of cryptographic primitives.
 */
interface SubtleCrypto {
    /**
     * Returns a `Promise` of the encrypted data corresponding to the clear text, algorithm and key given as parameters.
     * @param algorithm     Object specifying the encryption function to be used and its parameters; if there are no parameters, algorithm can be a `DOMString` with the algorithm name
     * @param key           `CryptoKey` containing the key to be used for encryption
     * @param data          `BufferSource` containing the data to be encrypted, the plaintext.
     * @return              `Promise` that returns the ciphertext generated by the encryption of the plaintext as an `ArrayBuffer`.
     */
    encrypt(algorithm: string | RsaOaepParams | AesCtrParams | AesCbcParams | AesCmacParams | AesGcmParams | AesCfbParams, key: CryptoKey, data: BufferSource): PromiseLike<ArrayBuffer>;
    /**
     * Returns a `Promise` of the clear data corresponding to the encrypted text, algorithm and key given as parameters.
     * @param algorithm     Object specifying the decryption function to be used and its parameters; if there are no parameters, algorithm can be a `DOMString` with the algorithm name
     * @param key           `CryptoKey` containing the key to be used for decryption
     * @param data          `BufferSource` containing the data to be decrypted, the ciphertext.
     * @return              `Promise` that returns the plaintext generated by the decryption of the ciphertext. 
     */
    decrypt(algorithm: string | RsaOaepParams | AesCtrParams | AesCbcParams | AesCmacParams | AesGcmParams | AesCfbParams, key: CryptoKey, data: BufferSource): PromiseLike<ArrayBuffer>;
    /**
     * Returns a Promise of a newly generated buffer of pseudo-random bits derived from a master key and a specific algorithm given as parameters.
     * @param algorithm     Object specifying the bits derivation function to be used and its parameters; if there are no parameters, algorithm can be a `DOMString` with the algorithm name
     * @param baseKey       Base key to be used by the key derivation algorithm.
     * @param length        The number of bits which must be derived
     * @return              `Promise` that returns `ArrayBuffer` of derived bits. 
     */
    deriveBits(algorithm: string | EcdhKeyDeriveParams | DhKeyDeriveParams | ConcatParams | HkdfCtrParams | Pbkdf2Params, baseKey: CryptoKey, length: number): PromiseLike<ArrayBuffer>;
    /**
     * Returns a Promise of a newly generated `CryptoKey` derived from a master key and a specific algorithm given as parameters.
     * @param algorithm     Object specifying the key derivation function to be used and its parameters; if there are no parameters, algorithm can be a `DOMString` with the algorithm name.
     * @param baseKey       Base key to be used by the key derivation algorithm.
     * @param derivedKeyType Object defining the algorithm the derived key will be used for.
     * @param extractable   Indicating if the key can be extracted from the `CryptoKey` object at a later stage
     * @param keyUsages     Indicating what can be done with the derived key. 
     * 
     * Possible values of the array are:
     * - __encrypt__, allowing the key to be used for encrypting messages.
     * - __decrypt__, allowing the key to be used for decrypting messages. -
     * - __sign__, allowing the key to be used for signing messages.
     * - __verify__, allowing the key to be used for verifying the signature of messages.
     * - __deriveKey__, allowing the key to be used as a base key when deriving a new key.
     * - __deriveBits__, allowing the key to be used as a base key when deriving bits of data for use in cryptographic primitives.
     * - __wrapKey__, allowing the key to wrap a symmetric key for usage (transfer, storage) in unsecure environments.
     * - __unwrapKey__, allowing the key to unwrap a symmetric key for usage (transfer, storage) in unsecure environments.
     * @return              `Promise` that returns the derived key as a `CryptoKey`.
     */
    deriveKey(algorithm: string | EcdhKeyDeriveParams | DhKeyDeriveParams | ConcatParams | HkdfCtrParams | Pbkdf2Params, baseKey: CryptoKey, derivedKeyType: string | AesDerivedKeyParams | HmacImportParams | ConcatParams | HkdfCtrParams | Pbkdf2Params, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;
    /**
     * Returns a Promise of a digest generated from the algorithm and text given as parameters.
     * @param algorithm     Object specifying the digest function to be used and its parameters; if there are no parameters, algorithm can be a `DOMString` with the algorithm name
     * @param data          `BufferSource` containing the data to be hashed using the hashing algorithm.
     * @return              `Promise` that returns the hash on success.
     */
    digest(algorithm: AlgorithmIdentifier, data: BufferSource): PromiseLike<ArrayBuffer>;
    /**
     * Returns a Promise of a buffer containing the key in the format requested.
     * @param format        enumerated value describing the data format of the key to be exported. 
     * 
     * It can be one of the following:
     * - __raw__, the key as an array of bytes, usually a secret key.
     * - __pkcs8__, a private key, in the IETF Public Key-Cryptographic Standard Encryption #8.
     * - __spki__, usually a public key, in the Simple public key infrastructure standard
     * - __jwk__, the key in the JSON Web Key format.
     * @param key           `CryptoKey` to be exported.
     * @return              `Promise` that returns the key in the requested format.
     */
    exportKey(format: "jwk", key: CryptoKey): PromiseLike<JsonWebKey>;
    exportKey(format: "raw" | "pkcs8" | "spki", key: CryptoKey): PromiseLike<ArrayBuffer>;
    exportKey(format: string, key: CryptoKey): PromiseLike<JsonWebKey | ArrayBuffer>;
    /**
     * Returns a `Promise` of a newly generated `CryptoKey`, for symmetrical algorithms, or a `CryptoKeyPair`, containing two newly generated keys, for asymmetrical algorithm, that matches the algorithm, the usages and the extractability given as parameters.
     * @param algorithm     Object specifying the key generation function to be used and its parameters; if there are no parameters, algorithm can be a `DOMString` with the algorithm name
     * @param extractable   Indicating if the key can be extracted from the `CryptoKey` object at a later stage
     * @param keyUsages     Indicating what can be done with the newly generated key. 
     * 
     * Possible values of the array are:
     * - __encrypt__, allowing the key to be used for encrypting messages.
     * - __decrypt__, allowing the key to be used for decrypting messages. -
     * - __sign__, allowing the key to be used for signing messages.
     * - __verify__, allowing the key to be used for verifying the signature of messages.
     * - __deriveKey__, allowing the key to be used as a base key when deriving a new key.
     * - __deriveBits__, allowing the key to be used as a base key when deriving bits of data for use in cryptographic primitives.
     * - __wrapKey__, allowing the key to wrap a symmetric key for usage (transfer, storage) in unsecure environments.
     * - __unwrapKey__, allowing the key to unwrap a symmetric key for usage (transfer, storage) in unsecure environments.
     * @return              `Promise` that returns the generated key as a `CryptoKey` or a `CryptoKeyPair`.
     */
    generateKey(algorithm: string, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKeyPair | CryptoKey>;
    generateKey(algorithm: RsaHashedKeyGenParams | EcKeyGenParams | DhKeyGenParams, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKeyPair>;
    generateKey(algorithm: AesKeyGenParams | HmacKeyGenParams | Pbkdf2Params, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;
    /**
     * Returns a `Promise` of a `CryptoKey` corresponding to the format, the algorithm, the raw key data, the usages and the extractability given as parameters.
     * @param format enumerated value describing the data format of the key to be imported. 
     * 
     * It can be one of the following:
     * - __raw__, the key as an array of bytes, usually a secret key.
     * - __pkcs8__, a private key, in the IETF Public Key-Cryptographic Standard Encryption #8.
     * - __spki__, usually a public key, in the Simple public key infrastructure standard
     * - __jwk__, the key in the JSON Web Key format.
     * @param algorithm     Object defining the algorithm the imported key will be used for.
     * @param extractable   Indicating if the key can be extracted from the `CryptoKey` object at a later stage
     * @param keyUsages     Indicating what can be done with the derived key. 
     * 
     * Possible values of the array are:
     * - __encrypt__, allowing the key to be used for encrypting messages.
     * - __decrypt__, allowing the key to be used for decrypting messages. -
     * - __sign__, allowing the key to be used for signing messages.
     * - __verify__, allowing the key to be used for verifying the signature of messages.
     * - __deriveKey__, allowing the key to be used as a base key when deriving a new key.
     * - __deriveBits__, allowing the key to be used as a base key when deriving bits of data for use in cryptographic primitives.
     * - __wrapKey__, allowing the key to wrap a symmetric key for usage (transfer, storage) in unsecure environments.
     * - __unwrapKey__, allowing the key to unwrap a symmetric key for usage (transfer, storage) in unsecure environments.
     * @return              `Promise` that returns the imported key as a `CryptoKey`.
     */
    importKey(format: "jwk", keyData: JsonWebKey, algorithm: string | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | DhImportKeyParams, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;
    importKey(format: "raw" | "pkcs8" | "spki", keyData: BufferSource, algorithm: string | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | DhImportKeyParams, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;
    importKey(format: string, keyData: JsonWebKey | BufferSource, algorithm: string | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | DhImportKeyParams, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;
    /**
     * Returns a `Promise` of the signature corresponding to the text, algorithm and key given as parameters.
     * @param algorithm     Object specifying the signing function to be used and its parameters; if there are no parameters, algorithm can be a `DOMString` with the algorithm name.
     * @param key           `CryptoKey` containing the key to be used for signing.
     * @param data          `BufferSource` containing the data to be signed.
     * @return              `Promise` that returns the signature on success.
     */
    sign(algorithm: string | RsaPssParams | EcdsaParams | AesCmacParams, key: CryptoKey, data: BufferSource): PromiseLike<ArrayBuffer>;
    /**
     * Returns a `Promise` of a `Boolean` value indicating if the signature given as parameter matches the text, algorithm and key also given as parameters.
     * @param algorithm     Object specifying the verifying function to be used and its parameters; if there are no parameters, algorithm can be a `DOMString` with the algorithm name.
     * @param key           `CryptoKey` containing the key to be used for verifying.
     * @param signature     `BufferSource` containing the signature to verify.
     * @param data          `BufferSource` containing the data whose signature as to be verified.
     * @return              `Promise` that returns a `Boolean` indicating if the signature has been a success on success.
     */
    verify(algorithm: string | RsaPssParams | EcdsaParams | AesCmacParams, key: CryptoKey, signature: BufferSource, data: BufferSource): PromiseLike<boolean>;
    /**
     * Returns a `Promise` of a `CryptoKey` corresponding to the wrapped key given in parameter.
     * @param format enumerated value describing the data format of the key to be unwrapped. 
     * 
     * It can be one of the following:
     * - __raw__, the key as an array of bytes, usually a secret key.
     * - __pkcs8__, a private key, in the IETF Public Key-Cryptographic Standard Encryption #8.
     * - __spki__, usually a public key, in the Simple public key infrastructure standard
     * - __jwk__, the key in the JSON Web Key format.
     * @param wrappedKey    `BufferSource` containing the wrapped key in the given format.
     * @param unwrappingKey `CryptoKey` to use to unwrap.
     * @param unwrapAlgorithm `Object` or `DOMString` epresenting the algorithm used to perform the unwrapping.
     * @param unwrappedKeyAlgorithm `Object` or `DOMString` defining the algorithm the unwrapped key will be used for.
     * @param extractable   Indicating if the key can be extracted from the `CryptoKey` object at a later stage
     * @param keyUsages     Indicating what can be done with the derived key. 
     * 
     * Possible values of the array are:
     * - __encrypt__, allowing the key to be used for encrypting messages.
     * - __decrypt__, allowing the key to be used for decrypting messages. -
     * - __sign__, allowing the key to be used for signing messages.
     * - __verify__, allowing the key to be used for verifying the signature of messages.
     * - __deriveKey__, allowing the key to be used as a base key when deriving a new key.
     * - __deriveBits__, allowing the key to be used as a base key when deriving bits of data for use in cryptographic primitives.
     * - __wrapKey__, allowing the key to wrap a symmetric key for usage (transfer, storage) in unsecure environments.
     * - __unwrapKey__, allowing the key to unwrap a symmetric key for usage (transfer, storage) in unsecure environments.
     * @return              `Promise` that returns the unwrapped key as a `CryptoKey`.
     */
    unwrapKey(format: string, wrappedKey: BufferSource, unwrappingKey: CryptoKey, unwrapAlgorithm: AlgorithmIdentifier, unwrappedKeyAlgorithm: AlgorithmIdentifier, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;
    /**
     * Returns a `Promise` of a wrapped symmetric key for usage (transfer, storage) in insecure environments. 
     * The wrapped buffer returned is in the format given in parameters, and contains the key wrapped by the given wrapping key with the given algorithm.
     * @param format enumerated value describing the data format of the key to be wrapped. 
     * 
     * It can be one of the following:
     * - __raw__, the key as an array of bytes, usually a secret key.
     * - __pkcs8__, a private key, in the IETF Public Key-Cryptographic Standard Encryption #8.
     * - __spki__, usually a public key, in the Simple public key infrastructure standard
     * - __jwk__, the key in the JSON Web Key format.
     * @param key           `CryptoKey` to wrap.
     * @param wrappingKey   `CryptoKey` used to perform the wrapping.
     * @param wrapAlgorithm `Object` or `DOMString` representing the algorithm used to perform the wrapping.
     * @return              `Promise` that returns the wrapped key in the requested format.
     */
    wrapKey(format: string, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgorithm: AlgorithmIdentifier): PromiseLike<ArrayBuffer>;
}

interface RsaKeyGenParams extends Algorithm {
    /**
     * The length, in bits, of the RSA modulus
     */
    modulusLength: number;
    /**
     * The RSA public exponent
     */
    publicExponent: Uint8Array;
}

interface RsaHashedKeyGenParams extends RsaKeyGenParams {
    /**
     * The hash algorithm to use
     */
    hash: AlgorithmIdentifier;
}

interface RsaKeyAlgorithm extends KeyAlgorithm {
    /**
     * The length, in bits, of the RSA modulus
     */
    modulusLength: number;
    /**
     * The RSA public exponent
     */
    publicExponent: Uint8Array;
}

interface RsaHashedKeyAlgorithm extends RsaKeyAlgorithm {
    /**
     * The hash algorithm that is used with this key
     */
    hash: AlgorithmIdentifier;
}

interface RsaHashedImportParams {
    /**
     * The hash algorithm to use
     */
    hash: AlgorithmIdentifier;
}

interface RsaPssParams {
    /**
     * The desired length of the random salt
     */
    saltLength: number;
}

interface RsaOaepParams extends Algorithm {
    /**
     * The label/application data to associate with the message
     */
    label?: BufferSource;
}

interface EcdsaParams extends Algorithm {
    /**
     * // The hash algorithm to use
     */
    hash: AlgorithmIdentifier;
}

interface EcKeyGenParams extends Algorithm {
    /**
     * A named curve
     */
    namedCurve: string;
}

interface EcKeyAlgorithm extends KeyAlgorithm {
    /**
     * A named curve
     */
    namedCurve: string;
}

interface EcKeyImportParams {
    /**
     * A named curve
     */
    namedCurve: string;
}

interface EcdhKeyDeriveParams extends Algorithm {
    /**
     * The peer's EC public key.
     */
    public: CryptoKey;
}

interface AesCtrParams extends Algorithm {
    /**
     * The initial value of the counter block. counter MUST be 16 bytes
     * (the AES block size). The counter bits are the rightmost length
     * bits of the counter block. The rest of the counter block is for
     * the nonce. The counter bits are incremented using the standard
     * incrementing function specified in NIST SP 800-38A Appendix B.1:
     * the counter bits are interpreted as a big-endian integer and
     * incremented by one.
     */
    counter: BufferSource;
    /**
     * The length, in bits, of the rightmost part of the counter block
     * that is incremented.
     */
    length: number;
}

interface AesKeyAlgorithm extends KeyAlgorithm {
    /**
     * The length, in bits, of the key.
     */
    length: number;
}

interface AesKeyGenParams extends Algorithm {
    /**
     * The length, in bits, of the key.
     */
    length: number;
}

interface AesDerivedKeyParams extends Algorithm {
    /**
     * The length, in bits, of the key.
     */
    length: number;
}

interface AesCbcParams extends Algorithm {
    /**
     * The initialization vector. MUST be 16 bytes.
     */
    iv: BufferSource;
}

interface AesCmacParams extends Algorithm {
    length: number;
}

interface AesGcmParams extends Algorithm {
    /**
     * The initialization vector to use. May be up to 2^64-1 bytes long.
     */
    iv: BufferSource;
    /**
     * The additional authentication data to include.
     */
    additionalData?: BufferSource;
    /**
     * The desired length of the authentication tag. May be 0 - 128.
     */
    tagLength?: number;
}

interface AesCfbParams extends Algorithm {
    iv: BufferSource;
}

interface HmacImportParams extends Algorithm {
    /**
     * The inner hash function to use.
     */
    hash: AlgorithmIdentifier;
    /**
     * The length (in bits) of the key.
     */
    length?: number;
}

interface HmacKeyAlgorithm extends KeyAlgorithm {
    /**
     * The inner hash function to use.
     */
    hash: AlgorithmIdentifier;
    /**
     * The length (in bits) of the key.
     */
    length: number;
}

interface HmacKeyGenParams extends Algorithm {
    /**
     * The inner hash function to use.
     */
    hash: AlgorithmIdentifier;
    /**
     * The length (in bits) of the key to generate. If unspecified, the
     * recommended length will be used, which is the size of the associated hash function's block
     * size.
     */
    length?: number;
}

interface DhKeyGenParams extends Algorithm {
    prime: Uint8Array;
    generator: Uint8Array;
}

interface DhKeyAlgorithm extends KeyAlgorithm {
    prime: Uint8Array;
    generator: Uint8Array;
}

interface DhKeyDeriveParams extends Algorithm {
    public: CryptoKey;
}

interface DhImportKeyParams extends Algorithm {
    prime: Uint8Array;
    generator: Uint8Array;
}

interface ConcatParams extends Algorithm {
    hash?: AlgorithmIdentifier;
    algorithmId: Uint8Array;
    partyUInfo: Uint8Array;
    partyVInfo: Uint8Array;
    publicInfo?: Uint8Array;
    privateInfo?: Uint8Array;
}

interface HkdfCtrParams extends Algorithm {
    hash: AlgorithmIdentifier;
    label: BufferSource;
    context: BufferSource;
}

interface Pbkdf2Params extends Algorithm {
    salt: BufferSource;
    iterations: number;
    hash: AlgorithmIdentifier;
}

interface RsaOtherPrimesInfo {
    r: string;
    d: string;
    t: string;
}

interface JsonWebKey {
    kty: string;
    use?: string;
    key_ops?: string[];
    alg?: string;
    kid?: string;
    x5u?: string;
    x5c?: string;
    x5t?: string;
    ext?: boolean;
    crv?: string;
    x?: string;
    y?: string;
    d?: string;
    n?: string;
    e?: string;
    p?: string;
    q?: string;
    dp?: string;
    dq?: string;
    qi?: string;
    oth?: RsaOtherPrimesInfo[];
    k?: string;
}

interface KeyAlgorithm {
    /**
     * The name of the algorithm used to generate the `CryptoKey`
     */
    name?: string;
}

interface Algorithm {
    /**
     * The name of the registered algorithm to use.
     */
    name: string;
}

/**
 * WebcryptoSocket is global object from webcrypto-socket.js
 */
export namespace WebcryptoSocket {
    class EventEmitter {
        static listenerCount(emitter: EventEmitter, event: string | symbol): number; // deprecated
        static defaultMaxListeners: number;

        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
        removeListener(event: string | symbol, listener: (...args: any[]) => void): this;
        removeAllListeners(event?: string | symbol): this;
        setMaxListeners(n: number): this;
        getMaxListeners(): number;
        listeners(event: string | symbol): Function[];
        emit(event: string | symbol, ...args: any[]): boolean;
        eventNames(): Array<string | symbol>;
        listenerCount(type: string | symbol): number;
    }

    // Crypto engine

    /**
     * Crypto engine structure
     */
    interface ICryptoEngine {
        /**
         * The name of used crypto engine
         */
        name: string;
        /**
         * Crypto implementation
         */
        crypto: Crypto;
    }

    /**
     * Sets crypto engine
     *
     * @param {string} name     Name of engine
     * @param {Crypto} crypto   WebCrypto implementation
     */
    export function setEngine(name: string, crypto: Crypto): void;

    /**
     * Returns crypto engine.
     * - It throws exception if engine is empty.
     *
     * @returns {ICryptoEngine}
     */
    export function getEngine(): ICryptoEngine;

    enum SocketCryptoState {
        connecting = 0,
        open = 1,
        closing = 2,
        closed = 3,
    }

    // Proto buffers

    /**
     * Class `ObjectProto` is the root of the class hierarchy for `protobuf` classes. Every class of `protobuf` has `ObjectProto` as a super class.
     */
    class ObjectProto {
        static importProto<T extends ObjectProto>(this: {
            new(): T;
        }, data: ArrayBuffer | ObjectProto): Promise<T>;
        protected raw?: ArrayBuffer | null;
        /**
         * Returns `true` if ObjectProto is empty, otherwise `false`
         */
        isEmpty(): boolean;
        /**
         * Returns `true` if object was changed, otherwise `false`
         */
        hasChanged(): boolean;
        /**
         * Fills object structure from 
         * @param data Incoming data. Can be `ArrayBuffer` or instance of `ObjectCrypto`
         */
        importProto(data: ArrayBuffer | ObjectProto): Promise<void>;
        /**
         * Returns encoded `protobuf` data
         */
        exportProto(): Promise<ArrayBuffer>;
    }

    /**
     * Class `BaseProto` is the root of the class hierarchy for `protobuf` classes in `WebcryptoSocket`. Every class of `protobuf` has `BaseProto` as a super class.
     */
    class BaseProto extends ObjectProto {
        /**
         * Sets/gets number version for `protobuf` message. Default value is `1`.
         */
        public version: number;
    }

    /**
     * Contains info about crypto provider
     */
    class ProviderCryptoProto extends BaseProto {
        /**
         * Sets/gets string identity of provider
         */
        public id: string;
        /**
         * Sets/gets string name of provider
         */
        public name: string;
        /**
         * Sets/gets boolean flag which indicates that provider doesn't allow to write data to it
         */
        public readOnly: boolean;
        /**
         * Gets list of supported algorithms
         */
        public readonly algorithms: string[];
        /**
         * Sets/gets boolean flag which indicates that provider is on token or Smart Card
         */
        public isRemovable: boolean;
        /**
         * Sets/gets hex string ATR for removable tokens
         */
        public atr: string;
    }

    /**
     * Contains info about remote crypto server
     */
    class ProviderInfoProto extends BaseProto {
        /**
         * Sets/gets string name of server provider
         */
        public name: string;
        /**
         * Gets list of providers on server
         */
        public readonly providers: ProviderCryptoProto[];
    }

    class ActionProto extends BaseProto {

        /**
         * Index for Protobufer's properties ID
         */
        public static INDEX: number;
        /**
         * Unique name of action
         */
        public static ACTION: string;
        /**
         * name of the action
         */
        public action: string;
        /**
         * Identity of action (needs to link request to response)
         */
        public actionId: string;
    }

    class ProviderTokenEventProto extends ActionProto {
        /**
         * List of added tokens
         */
        public added: ProviderCryptoProto[];
        /**
         * List of removed tokens
         */
        public removed: ProviderCryptoProto[];
        /**
         * Contains error description when error occurs on token insertion/removing.
         */
        public error?: string;
    }

    class ProviderAuthorizedEventProto extends ActionProto {
    }

    /**
     * Associative array of crypto objects
     */
    interface CryptoArray {
        [id: string]: Crypto;
    }

    /**
     * Supports methods to communicate between crypto server and client
     */
    export class SocketProvider extends EventEmitter {
        /**
         * Gets assoc array of Crypto
         */
        public readonly crypto: CryptoArray;
        /**
         * Gets socket state
         */
        public readonly state: SocketCryptoState;

        /**
         * Creates new instance of SocketProvider
         */
        constructor();

        /**
         * Connect to local server
         * @param address <domain|ip>[:port] of local server. 127.0.0.1:31337
         */
        public connect(address: string): this;
        /**
         * Close connection
         */
        public close(): void;
        /**
         * Emits when error occurs
         * @param event         String name of event
         * @param listener      Callback function
         */
        public on(event: "error", listener: (error: Error) => void): this;
        /**
         * Emits when client was connected to server successfully
         * @param event         String name of event
         * @param listener      Callback function
         */
        public on(event: "listening", listener: (address: string) => void): this;
        /**
         * Emits when client was disconnected from server
         * @param event         String name of event
         * @param listener      Callback function
         */
        public on(event: "close", listener: (address: string) => void): this;
        /**
         * Emits when client insert/remove token or smart card
         * @param event         String name of event
         * @param listener      Callback function
         */
        public on(event: "token", listener: (info: ProviderTokenEventProto) => void): this;
        /**
         * Emits when client approved connection to current site
         * @param event         String name of event
         * @param listener      Callback function
         */
        public on(event: "auth", listener: (info: ProviderAuthorizedEventProto) => void): this;
        public on(event: string | symbol, listener: (...args: any[]) => void): this;
        /**
         * Emits when error occurs
         * @param event         String name of event
         * @param listener      Callback function
         */
        public once(event: "error", listener: (error: Error) => void): this;
        /**
         * Emits when client was connected to server successfully
         * @param event         String name of event
         * @param listener      Callback function
         */
        public once(event: "listening", listener: (address: string) => void): this;
        /**
         * Emits when client was disconnected from server
         * @param event         String name of event
         * @param listener      Callback function
         */
        public once(event: "close", listener: (address: string) => void): this;
        /**
         * Emits when client insert/remove token or smart card
         * @param event         String name of event
         * @param listener      Callback function
         */
        public once(event: "token", listener: (info: ProviderTokenEventProto) => void): this;
        /**
         * Emits when client approved connection to current site
         * @param event         String name of event
         * @param listener      Callback function
         */
        public once(event: "auth", listener: (info: ProviderAuthorizedEventProto) => void): this;
        public once(event: string | symbol, listener: (...args: any[]) => void): this;
        /**
         * Returns info about remote server providers
         */
        public info(): Promise<ProviderInfoProto>;
        /**
         * Returns 6 digit number based on client's identity and server's identity 
         */
        public challenge(): Promise<string>;
        /**
         * Returns `true` if current session is approved, otherwise `false`
         */
        public isLoggedIn(): Promise<boolean>;
        /**
         * Request approve for current session. `Fortify` app shows approval windows
         */
        public login(): Promise<void>;
        /**
         * Returns Crypto by id
         * @param cryptoID id of key
         */
        public getCrypto(cryptoID: string): Promise<SocketCrypto>;
    }

    /**
     * Provides basic methods for key storage
     */
    interface IKeyStorage {

        /**
         * Return list of names of stored keys
         * - each name has format like `<type>-<handle>-<id>`
         *   - `type` is string name of type of key. Can be `private`, `public` or `secret`
         *   - `handle` hex string of `CK_HANDLE` value of PKCS#11 object
         *   - `id` is hex string of sha256 digest of CKA_ID of PKCS#11 object. `public` and `private` which has equals `id` part are key pair
         */
        keys(): Promise<string[]>;

        /**
         * Returns identity of item from key storage.
         * - If item is not found, then returns `null`
         */
        indexOf(item: CryptoKey): Promise<string | null>;
        /**
         * Returns key from storage
         * 
         * @param key string identity of item in storage
         */
        getItem(key: string): Promise<CryptoKey>;
        getItem(key: string, algorithm: Algorithm, usages: string[]): Promise<CryptoKey>;
        /**
         * Add key to storage
         * 
         * @param value Value which must be added to storage
         * @return Returns string identity of item in storage
         */
        setItem(value: CryptoKey): Promise<string>;

        /**
         * Removes item from storage by given key
         * 
         * @param key string identity if item in storage
         */
        removeItem(key: string): Promise<void>;
        /**
         * Removes all items from storage
         */
        clear(): Promise<void>;
    }

    /**
     * String in HEX format
     */
    type HexString = string;

    /**
     * Type of CryptoCertificate object
     */
    type CryptoCertificateType = string | "x509" | "request";

    interface ICryptoCertificate {
        /**
         * Get type of `CryptoCertificate`. It can be `x509` or `request`.
         */
        type: CryptoCertificateType;
        /**
         * Gets public key
         */
        publicKey: CryptoKey;
    }

    interface ICryptoX509Certificate extends ICryptoCertificate {
        /**
         * Gets the date before which this certificate is not valid.
         */
        notBefore: Date;
        /**
         * Gets the date after which this certificate is not valid.
         */
        notAfter: Date;
        /**
         * Gets the serial number of this attribute certificate.
         */
        serialNumber: HexString;
        /**
         * Gets string issuer name of this certificates.
         * - It has format `<Short name | OID>=<value>[, <Short name | OID>=<value>]`
         */
        issuerName: string;
        /**
         * Gets string subject name of this certificates.
         * - It has format `<Short name | OID>=<value>[, <Short name | OID>=<value>]`
         */
        subjectName: string;
    }

    interface CryptoX509CertificateRequest extends ICryptoCertificate {
        /**
         * Gets string subject name of this request.
         * - It has format `<Short name | OID>=<value>[, <Short name | OID>=<value>]`
         */
        subjectName: string;
    }

    /**
     * Provides basic methods for certificate storage
     */
    interface ICertificateStorage {

        /**
         * Returns a list of indexes
         */
        keys(): Promise<string[]>;
        /**
         * Returns index by object. If item not fount returns null
         */
        indexOf(item: ICryptoCertificate): Promise<string | null>;

        /**
         * Import certificate from data
         * 
         * @param   type    Type of certificate
         * @param   data    Raw of certificate item
         */
        importCert(type: "request", data: BufferSource, algorithm: Algorithm, keyUsages: string[]): Promise<CryptoX509CertificateRequest>;
        importCert(type: "x509", data: BufferSource, algorithm: Algorithm, keyUsages: string[]): Promise<ICryptoX509Certificate>;
        importCert(type: CryptoCertificateType, data: BufferSource, algorithm: Algorithm, keyUsages: string[]): Promise<ICryptoCertificate>;

        /**
         * Export item from storage
         * @param   format      Format of exported data
         * @param   item        Item which must be exported
         * @return              Result base on format parameter
         */
        exportCert(format: "pem", item: ICryptoCertificate): Promise<string>
        exportCert(format: "raw", item: ICryptoCertificate): Promise<ArrayBuffer>
        exportCert(format: CryptoCertificateType, item: ICryptoCertificate): Promise<ArrayBuffer | string>

        /**
         * Adds item to storage
         */
        setItem(item: ICryptoCertificate): Promise<string>;
        getItem(key: string): Promise<ICryptoCertificate>;
        getItem(key: string, algorithm: Algorithm, keyUsages: string[]): Promise<ICryptoCertificate>;
        /**
         * Removes item from storage by id
         */
        removeItem(key: string): Promise<void>;
        /**
         * Removes all items from storage
         */
        clear(): Promise<void>;
        /**
         * Returns chain for certificate
         * @param value     Entry `Certificate` for chain builder
         */
        getChain(value: ICryptoX509Certificate): Promise<ChainItem>;
        /**
         * Gets crl from URI
         * @param url       Reference to CRL
         */
        getCRL(url: string): Promise<ArrayBuffer>;
        /**
         * Gets OCSP request from URI
         * @param url       Reference to OCSP controller
         * @param request   DER encoded OCSP request
         * @param options   Options for request. Default `method` is `get`
         * @return          DER encoded OCSP response
         */
        getOCSP(url: string, request: ArrayBuffer, options?: OCSPRequestOptions): Promise<ArrayBuffer>;
    }

    interface OCSPRequestOptions {
        /**
         * Method for sending request
         */
        method: "post" | "get";
    }

    interface ChainItem {
        /**
         * Type of this `ChainItem`
         */
        type: string | "x509" | "crl" | "ocsp",
        /**
         * DER encoded PKI data
         */
        value: ArrayBuffer;
    }

    class SocketCrypto implements Crypto {
        /**
         * Gets identity of Crypto
         */
        public id: string;
        /**
         * Get a set of cryptographic primitives
         */
        public subtle: SubtleCrypto;
        /**
         * Gets a storage of crypto keys
         */
        public keyStorage: IKeyStorage;
        /**
         * Gets a storage of certificates and certificate requests
         */
        public certStorage: ICertificateStorage;
        /**
         * Fills the passed `TypedArray` with cryptographically sound random values.
         * @param data Is an integer-based TypedArray, that is an Int8Array, a Uint8Array, an Int16Array, a Uint16Array, an Int32Array, or a Uint32Array. All elements in the array are going to be overridden with random numbers.
         */
        public getRandomValues(data: ArrayBufferView): ArrayBufferView
        /**
         * Returns `true` if provider(token) is logged in, otherwise `false`
         */
        public isLoggedIn(): Promise<boolean>;
        /**
         * Login to PKCS#11 session
         * - Shows Login window in Fortify.
         */
        public login(): Promise<void>;
        /**
         * Reset token's session. Refreshes list of objects for keyStorage and certStorage
         * - `C_SessionClose` + `C_SessionOpen`
         */
        public reset(): Promise<void>;
    }
}
